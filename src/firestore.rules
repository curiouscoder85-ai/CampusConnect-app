
/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for personal data and teacher-ownership for course-related data.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Only the user can read/write their own profile. Admins can read all profiles.
 * - /users/{userId}/chatHistory/{messageId}: Stores chat messages for a user. Only the user can read/write their own history.
 * - /courses/{courseId}: Stores course information. Only the teacher who created the course can modify it.
 * - /users/{userId}/certificates/{certificateId}: Stores certificates earned by users. Only the user can access their own certificates.
 * - /courses/{courseId}/assignments/{assignmentId}: Stores assignments for a course.
 * - /courses/{courseId}/assignments/{assignmentId}/submissions/{submissionId}: Stores student submissions for an assignment.
 * - /courses/{courseId}/feedback/{feedbackId}: Stores feedback for each course. Only the teacher who created the course can manage feedback. Students can create feedback.
 * - /enrollments/{enrollmentId}: Stores enrollment records. Only the student or the teacher of the course can access. Student can update their own progress.
 * - /users/{userId}/recommendations/{recommendationId}: Stores AI-powered content recommendations for each student. Only the user can access their own recommendations.
 *
 * Key Security Decisions:
 * - User listing is allowed for all signed-in users.
 * - Data shapes are not strictly enforced, focusing on authorization.
 * - Ownership is enforced using path-based matching and denormalized fields like 'teacherId'.
 * - Ambiguous relationships default to strict owner-only access.
 *
 * Denormalization for Authorization:
 * - Course documents have a `teacherId` field to identify the owner.
 * - Enrollment, Submission, and Feedback documents store `courseId`, `studentId`, and `teacherId`.
 *
 * Structural Segregation:
 * - User-specific data (e.g., certificates, recommendations, chatHistory) is stored under `/users/{userId}` to ensure private access.
 * - Submissions are a subcollection under assignments.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isRole(role) {
      let userDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return isSignedIn() && userDoc.data.role == role;
    }

    function isOwner(ownerId) {
      return isSignedIn() && request.auth.uid == ownerId;
    }
    
    function isTeacherOfCourse(courseId) {
        return isSignedIn() && get(/databases/$(database)/documents/courses/$(courseId)).data.teacherId == request.auth.uid;
    }

    match /users/{userId} {
      allow list: if isSignedIn();
      allow get: if isSignedIn();
      allow create: if (isOwner(userId) && request.resource.data.id == userId) || isRole('admin');
      allow update: if isOwner(userId) || isRole('admin');
      allow delete: if isRole('admin');

      match /chatHistory/{messageId} {
        allow list, get, create, update, delete: if isOwner(userId);
      }
    }

    match /courses/{courseId} {
      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && request.resource.data.teacherId == request.auth.uid && isRole('teacher');
      allow update: if (isTeacherOfCourse(courseId) || isRole('admin'));
      allow delete: if (isTeacherOfCourse(courseId) || isRole('admin'));
      
      match /assignments/{assignmentId}/submissions/{submissionId} {
        function isStudentOwner() {
            // Note: This rule uses `resource.data` which is for get/update/delete.
            // For create, it should be `request.resource.data`.
            return isSignedIn() && resource.data.userId == request.auth.uid;
        }
        
        allow get: if isStudentOwner() || isTeacherOfCourse(courseId);
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update: if isTeacherOfCourse(courseId); // Allow teacher to update (e.g., for grading)
        allow delete: if isStudentOwner() || isTeacherOfCourse(courseId);
      }
    }

    match /users/{userId}/certificates/{certificateId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    match /courses/{courseId}/feedback/{feedbackId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isTeacherOfCourse(courseId);
      allow delete: if isTeacherOfCourse(courseId);
    }

    match /enrollments/{enrollmentId} {
      function isStudentEnrolled(studentId) {
          return isSignedIn() && request.auth.uid == studentId;
      }

      allow get: if isStudentEnrolled(resource.data.userId) || isTeacherOfCourse(resource.data.courseId);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if (isStudentEnrolled(resource.data.userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['progress', 'completedContent'])) || isTeacherOfCourse(resource.data.courseId);
      allow delete: if isStudentEnrolled(resource.data.userId) || isTeacherOfCourse(resource.data.courseId);
    }

    match /users/{userId}/recommendations/{recommendationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }
    
    // This allows collection group queries on feedback and submissions
    match /{path=**}/feedback/{feedbackId} {
      allow list: if isRole('admin') || isRole('teacher');
    }
    
    // This rule allows a teacher to list all submissions across all courses.
    // This is secure because the client-side query MUST filter by teacherId.
    // This rule allows a student to list their own submissions.
    match /{path=**}/submissions/{submissionId} {
      allow list: if (isRole('teacher') && request.query.where.teacherId == request.auth.uid) ||
                     (isRole('student') && request.query.where.userId == request.auth.uid);
    }
  }
}
